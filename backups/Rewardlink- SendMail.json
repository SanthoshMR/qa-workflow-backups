{
  "active": false,
  "connections": {
    "Function": {
      "main": [
        [
          {
            "node": "Item Lists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Function",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AWS SES": {
      "main": [
        [
          {
            "node": "Insert SES Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF": {
      "main": [
        [],
        [
          {
            "node": "Zepto Item Lists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Zepto Item Lists": {
      "main": [
        [
          {
            "node": "Function2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Function3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Function3": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Item Lists": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Send Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2023-12-14T12:49:39.208Z",
  "id": "391",
  "name": "Rewardlink- SendMail",
  "nodes": [
    {
      "parameters": {},
      "name": "Start",
      "type": "n8n-nodes-base.start",
      "typeVersion": 1,
      "position": [
        -120,
        340
      ]
    },
    {
      "parameters": {
        "functionCode": "/*let dataArray = $node[\"Webhook\"].json[\"body\"];\nlet modifiedContentArray1 = [];\nlet content_array = $node[\"Webhook\"].json[\"body\"][\"modifiedContentArray\"];\nlet content_field = $node[\"Webhook\"].json[\"body\"][\"content_data\"];\n\nfor (let i = 0; i < content_array.length; i++) {\n  let content = content_field; // Copy the original content_data\n  let currentItem = content_array[i];\nlet formattedDate1 = currentItem.enddate;\nlet amount = parseInt(currentItem.amount);\n      const date = new Date(formattedDate1);\n  const options = { day: '2-digit', month: 'short', year: 'numeric' };\n  const formattedDate = date.toLocaleDateString('en-US', options);\n  // Replace placeholders in the content with corresponding values from the current item\n content = content.replace(/{link}/g, currentItem.linkId)\n    .replace(/{img}/g, currentItem.imageSrc)\n    .replace(/{shakepelink}/g, currentItem.shakepelink)\n    .replace(/{enddate}/g, formattedDate)\n    .replace(/{amount}/g, amount)\n    .replace(/{name}/g, currentItem.name);\n     \nlet linkObj = {\n        content:content ,\n        shakepelink: currentItem.shakepelink,\n        name: currentItem.name,\n        imageSrc: currentItem.imageSrc,\n        enddate:formattedDate,\n        email:currentItem.email,\n        subject:currentItem.subject,\n         campaign_name:currentItem.campaign_name,\n        from:currentItem.from,\n        linkId: currentItem.linkId,\n        is_attachment_required : currentItem.is_attachment_required,\n        attachment : currentItem.attachment\n  };\n\n      \n  modifiedContentArray1.push(linkObj);\n}\n\nreturn { modifiedContentArray1 };*/\n\n\n\nlet dataArray = $node[\"Webhook\"].json[\"body\"];\nlet modifiedContentArray1 = [];\nlet content_array = dataArray[\"modifiedContentArray\"];\nlet content_field = dataArray[\"content_data\"];\n\n// Initialize binaries outside the loop\nlet binaries = {};\n\nlet binary_keys = [];\nlet uploadDocument = [];\nlet extension = [];\n\nfor (const [index, item] of items.entries()) {\n    const filename =  $node[\"HTTP Request\"].binary.data.fileName; \n\n    item.binary.data.fileName = `${filename}.pdf`;\n\n    for (let i = 0; i < content_array.length; i++) {\n\n        let extension = \"pdf\";\n        binaries[`data_${i}.${extension}`] = item.binary.data;\n        binary_keys.push(`data_${i}.${extension}`);\n        uploadDocument.push(`input_file${i}:data_${i}.${extension}`);\n        \n        let currentItem = content_array[i];\n        let formattedDate1 = currentItem.enddate;\n        let amount = parseInt(currentItem.amount);\n        const date = new Date(formattedDate1);\n        const options = { day: '2-digit', month: 'short', year: 'numeric' };\n        const formattedDate = date.toLocaleDateString('en-US', options);\n\n        let content = content_field.replace(/{link}/g, currentItem.linkId)\n            .replace(/{img}/g, currentItem.imageSrc)\n            .replace(/{shakepelink}/g, currentItem.shakepelink)\n            .replace(/{enddate}/g, formattedDate)\n            .replace(/{amount}/g, amount)\n            .replace(/{name}/g, currentItem.name);\n\n        // Build binaries for HTTP Request\n        // let extension = \"pdf\";\n        let key = `data_${i}.${extension}`;\n\n        // Include the attachment directly as binary data\n        // binaries[key] = currentItem.attachment; // Assuming currentItem.attachment is already in binary format\n\n        let linkObj = {\n        content: content,\n            shakepelink: currentItem.shakepelink,\n            name: currentItem.name,\n            imageSrc: currentItem.imageSrc,\n            enddate: formattedDate,\n            email: currentItem.email,\n            subject: currentItem.subject,\n            campaign_name: currentItem.campaign_name,\n            from: currentItem.from,\n            linkId: currentItem.linkId,\n            is_attachment_required: currentItem.is_attachment_required,\n            attachment:currentItem.attachment,\n            binary_keys: key\n        };\n\n        modifiedContentArray1.push(linkObj);\n    }\n}\n\n\n\nreturn [{\n    json: {\n        modifiedContentArray1: modifiedContentArray1,\n        \n    },\n    binary: binaries\n}];\n\n\n"
      },
      "name": "Function",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        400,
        320
      ]
    },
    {
      "parameters": {
        "fieldToSplitOut": "=modifiedContentArray1",
        "options": {}
      },
      "name": "Item Lists",
      "type": "n8n-nodes-base.itemLists",
      "typeVersion": 1,
      "position": [
        600,
        320
      ]
    },
    {
      "parameters": {
        "fromEmail": "={{$node[\"Item Lists\"].json[\"from\"]}}",
        "toEmail": "={{$node[\"Item Lists\"].json[\"email\"]}}",
        "subject": "={{$node[\"Item Lists\"].json[\"subject\"]}}",
        "html": "={{$node[\"Item Lists\"].json[\"content\"]}}",
        "attachments": "= {{$node[\"Merge\"].json[\"binary_keys\"]}}",
        "options": {}
      },
      "name": "Send Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 1,
      "position": [
        940,
        300
      ],
      "credentials": {
        "smtp": {
          "id": "103",
          "name": "SMTP account(Roopa)"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "154d1988-0513-40ed-b4a9-715db353307b",
        "options": {}
      },
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        160,
        320
      ],
      "webhookId": "154d1988-0513-40ed-b4a9-715db353307b"
    },
    {
      "parameters": {
        "isBodyHtml": true,
        "subject": "={{$node[\"Item Lists\"].json[\"subject\"]}}",
        "body": "={{$node[\"Item Lists\"].json[\"content\"]}}",
        "fromEmail": "={{$node[\"Item Lists\"].json[\"from\"]}}",
        "toAddresses": [
          "={{$node[\"Item Lists\"].json[\"email\"]}}"
        ],
        "additionalFields": {
          "configurationSetName": "ses-qa"
        }
      },
      "name": "AWS SES",
      "type": "n8n-nodes-base.awsSes",
      "typeVersion": 1,
      "position": [
        1380,
        300
      ],
      "credentials": {
        "aws": {
          "id": "106",
          "name": "AWS account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "let dataArray = $node[\"AWS SES\"].json[\"SendEmailResponse\"];\r\nreturn {dataArray};"
      },
      "name": "Function1",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1400,
        80
      ]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "requestMethod": "POST",
        "url": "=https://zeusqa.shakedeal.com/items/sd_delivery_logs",
        "options": {},
        "bodyParametersUi": {
          "parameter": [
            {
              "name": "order_id",
              "value": "={{$node[\"Item Lists\"].json[\"campaign_name\"]}}"
            },
            {
              "name": "message_id",
              "value": "={{$node[\"AWS SES\"].json[\"SendEmailResponse\"][\"SendEmailResult\"][\"MessageId\"]}}"
            },
            {
              "name": "status",
              "value": "Send"
            },
            {
              "name": "recipient",
              "value": "={{$node[\"Item Lists\"].json[\"email\"]}}"
            },
            {
              "name": "source",
              "value": "=Campaigns"
            },
            {
              "name": "template"
            }
          ]
        }
      },
      "name": "Insert SES Log",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1580,
        300
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "81",
          "name": "SES Auth"
        }
      }
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "=https://api.zeptomail.com/v1.1/email",
        "jsonParameters": true,
        "options": {}
      },
      "name": "Zepto Mail",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        120,
        860
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$node[\"Webhook\"].json[\"body\"][\"mail_server\"]}}",
              "value2": "SendGrid"
            }
          ]
        }
      },
      "name": "IF",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        320,
        960
      ]
    },
    {
      "parameters": {
        "fieldToSplitOut": "modifiedContentArray1",
        "options": {}
      },
      "name": "Zepto Item Lists",
      "type": "n8n-nodes-base.itemLists",
      "typeVersion": 1,
      "position": [
        360,
        980
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "=https://api.zeptomail.com/v1.1/email",
        "options": {
          "bodyContentType": "json"
        },
        "bodyParametersUi": {
          "parameter": [
            {
              "name": "bounce_address",
              "value": "=bounces@zep.shakepe.com"
            },
            {
              "name": "from",
              "value": "={ \"address\": \"rewards@shakepe.com\", \"name\": \"ShakePe Rewards\"}"
            },
            {
              "name": "to",
              "value": "=[{\"email_address\": {\"address\": \"{{$node[\"Zepto Item Lists\"].json[\"email\"]}}\",\"name\": \"{{$node[\"Zepto Item Lists\"].json[\"name\"]}}\"}}]"
            },
            {
              "name": "subject",
              "value": "={{$node[\"Zepto Item Lists\"].json[\"subject\"]}}"
            },
            {
              "name": "htmlbody",
              "value": "={{$node[\"Zepto Item Lists\"].json[\"content\"]}}"
            },
            {
              "name": "attachments",
              "value": "=[{\"file_cache_key\": \"2d6f.3899390d815a995e.h1.d4f13f60-b134-11ee-b998-5254004d4100.18cfd340e56\",\"mime_type\":\"application/pdf\",\"name\": \"Voucher-Redemption.pdf\"}]"
            }
          ]
        },
        "headerParametersUi": {
          "parameter": [
            {
              "name": "Authorization",
              "value": "Zoho-enczapikey wSsVR6118xTxD/8vzWKpL+s4mlRSAV6gQU963QGmv3H5Hf2Wp8dtw0bPBw6iFPkbF2ZhFGMWpu18mB8JgGVfj9l/mV1UXiiF9mqRe1U4J3x17qnvhDzDW2xakxSJKY4Ozg5jnGFlG8ki+g=="
            }
          ]
        }
      },
      "name": "Zepto Mail1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        120,
        840
      ]
    },
    {
      "parameters": {
        "functionCode": "let mail_content = $node[\"Zepto Item Lists\"].json;\n\nlet result = {};\n\n\n\n\n\nreturn result;\n"
      },
      "name": "Function2",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        380,
        980
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "=https://api.zeptomail.com/v1.1/email",
        "options": {
          "bodyContentType": "json"
        },
        "bodyParametersUi": {
          "parameter": [
            {
              "name": "bounce_address",
              "value": "=bounces@zep.shakepe.com"
            },
            {
              "name": "from",
              "value": "={ \"address\": \"rewards@shakepe.com\", \"name\": \"ShakePe Rewards\"}"
            },
            {
              "name": "to",
              "value": "=[{\"email_address\": {\"address\": \"{{$node[\"Zepto Item Lists\"].json[\"email\"]}}\",\"name\": \"{{$node[\"Zepto Item Lists\"].json[\"name\"]}}\"}}]"
            },
            {
              "name": "subject",
              "value": "={{$node[\"Zepto Item Lists\"].json[\"subject\"]}}"
            },
            {
              "name": "htmlbody",
              "value": "={{$node[\"Zepto Item Lists\"].json[\"content\"]}}"
            }
          ]
        },
        "headerParametersUi": {
          "parameter": [
            {
              "name": "Authorization",
              "value": "Zoho-enczapikey wSsVR6118xTxD/8vzWKpL+s4mlRSAV6gQU963QGmv3H5Hf2Wp8dtw0bPBw6iFPkbF2ZhFGMWpu18mB8JgGVfj9l/mV1UXiiF9mqRe1U4J3x17qnvhDzDW2xakxSJKY4Ozg5jnGFlG8ki+g=="
            }
          ]
        }
      },
      "name": "Zepto Mail2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        120,
        840
      ]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "https://campaignsqa.shakepe.com/assets/2f285a67-3487-4be3-a6e8-d03465d996cf",
        "responseFormat": "file",
        "options": {}
      },
      "name": "HTTP Request",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        200,
        560
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "102",
          "name": "Header Auth account 2(campaign qa)"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "let binaries = {};\nlet binary_keys = [];\nlet uploadDocument = [];\nlet extension = [];\n\nfor (const [index, item] of items.entries()) {\n   \n    const filename =  $node[\"HTTP Request\"].binary.data.fileName; \n\n    item.binary.data.fileName = `${filename}.pdf`;\n\n    let extension = \"pdf\";\n    binaries[`data_${index}.${extension}`] = item.binary.data;\n    binary_keys.push(`data_${index}.${extension}`);\n    uploadDocument.push(`input_file${index}:data_${index}.${extension}`);\n}\n\nreturn [{\n    json: {\n        binary_keys: binary_keys.join(',')\n    },\n    binary: binaries\n}];\n"
      },
      "name": "Function3",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        420,
        560
      ]
    },
    {
      "parameters": {
        "mode": "mergeByIndex",
        "join": "outer"
      },
      "name": "Merge",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 1,
      "position": [
        700,
        540
      ]
    },
    {
      "parameters": {
        "functionCode": "/*let dataArray = $node[\"Webhook\"].json[\"body\"];\nlet modifiedContentArray1 = [];\nlet content_array = $node[\"Webhook\"].json[\"body\"][\"modifiedContentArray\"];\nlet content_field = $node[\"Webhook\"].json[\"body\"][\"content_data\"];\n\nfor (let i = 0; i < content_array.length; i++) {\n  let content = content_field; // Copy the original content_data\n  let currentItem = content_array[i];\nlet formattedDate1 = currentItem.enddate;\nlet amount = parseInt(currentItem.amount);\n      const date = new Date(formattedDate1);\n  const options = { day: '2-digit', month: 'short', year: 'numeric' };\n  const formattedDate = date.toLocaleDateString('en-US', options);\n  // Replace placeholders in the content with corresponding values from the current item\n content = content.replace(/{link}/g, currentItem.linkId)\n    .replace(/{img}/g, currentItem.imageSrc)\n    .replace(/{shakepelink}/g, currentItem.shakepelink)\n    .replace(/{enddate}/g, formattedDate)\n    .replace(/{amount}/g, amount)\n    .replace(/{name}/g, currentItem.name);\n     \nlet linkObj = {\n        content:content ,\n        shakepelink: currentItem.shakepelink,\n        name: currentItem.name,\n        imageSrc: currentItem.imageSrc,\n        enddate:formattedDate,\n        email:currentItem.email,\n        subject:currentItem.subject,\n         campaign_name:currentItem.campaign_name,\n        from:currentItem.from,\n        linkId: currentItem.linkId,\n        is_attachment_required : currentItem.is_attachment_required,\n        attachment : currentItem.attachment\n  };\n\n      \n  modifiedContentArray1.push(linkObj);\n}\n\nreturn { modifiedContentArray1 };\n\n\n*/\n\n\n\n/*\nlet dataArray = $node[\"Webhook\"].json[\"body\"];\nlet modifiedContentArray1 = [];\nlet content_array = dataArray[\"modifiedContentArray\"];\nlet content_field = dataArray[\"content_data\"];\n\n// Initialize binaries outside the loop\nlet binaries = {};\nlet binary_keys = [];\n\nfor (let i = 0; i < content_array.length; i++) {\n    let content = content_field;\n    let currentItem = content_array[i];\n    let formattedDate1 = currentItem.enddate;\n    let amount = parseInt(currentItem.amount);\n    const date = new Date(formattedDate1);\n    const options = { day: '2-digit', month: 'short', year: 'numeric' };\n    const formattedDate = date.toLocaleDateString('en-US', options);\n\n    content = content.replace(/{link}/g, currentItem.linkId)\n        .replace(/{img}/g, currentItem.imageSrc)\n        .replace(/{shakepelink}/g, currentItem.shakepelink)\n        .replace(/{enddate}/g, formattedDate)\n        .replace(/{amount}/g, amount)\n        .replace(/{name}/g, currentItem.name);\n\n    // Build binaries for HTTP Request\n    let extension = \"pdf\";\n    let key = `data_${i}.${extension}`;\n\n    // Use a specific file name for each binary key\n    let fileName = `${currentItem.attachment}_${i}.${extension}`;\n\n    // Ensure currentItem.attachment is base64-encoded binary data\n    binaries[key] = Buffer.from(currentItem.attachment, 'base64'); // Convert base64 to binary buffer\n\n    binary_keys.push(key);\n\n    let linkObj = {\n        content: content,\n        shakepelink: currentItem.shakepelink,\n        name: currentItem.name,\n        imageSrc: currentItem.imageSrc,\n        enddate: formattedDate,\n        email: currentItem.email,\n        subject: currentItem.subject,\n        campaign_name: currentItem.campaign_name,\n        from: currentItem.from,\n        linkId: currentItem.linkId,\n        is_attachment_required: currentItem.is_attachment_required,\n        attachment: {\n            data: \"\", // Use the binary buffer\n            fileName: fileName\n        },\n        binary_keys: binary_keys.slice() // Include a copy of binary_keys for each linkObj\n    };\n\n    modifiedContentArray1.push(linkObj);\n\n    // Clear binary_keys for the next iteration\n    binary_keys = [];\n}\n\n\nreturn [{\n    json: {\n        modifiedContentArray1: modifiedContentArray1\n    },\n    binary: binaries\n}];\n\n*/\n\n\n/*\nlet dataArray = $node[\"Webhook\"].json[\"body\"];\nlet modifiedContentArray1 = [];\nlet content_array = dataArray[\"modifiedContentArray\"];\nlet content_field = dataArray[\"content_data\"];\n\n// Initialize binaries outside the loop\nlet binaries = {};\nlet binary_keys = [];\n\nfor (let i = 0; i < content_array.length; i++) {\n    let content = content_field;\n    let currentItem = content_array[i];\n    let formattedDate1 = currentItem.enddate;\n    let amount = parseInt(currentItem.amount);\n    const date = new Date(formattedDate1);\n    const options = { day: '2-digit', month: 'short', year: 'numeric' };\n    const formattedDate = date.toLocaleDateString('en-US', options);\n\n    content = content.replace(/{link}/g, currentItem.linkId)\n        .replace(/{img}/g, currentItem.imageSrc)\n        .replace(/{shakepelink}/g, currentItem.shakepelink)\n        .replace(/{enddate}/g, formattedDate)\n        .replace(/{amount}/g, amount)\n        .replace(/{name}/g, currentItem.name);\n\n    // Build binaries for HTTP Request\n    let extension = \"pdf\";\n    let key = `data_${i}.${extension}`;\n\n    // Use a specific file name for each binary key\n    let fileName = `${currentItem.attachment}_${i}.${extension}`;\n\n    // Include the attachment directly as binary data\n    binaries[key] = currentItem.attachment; // Assuming currentItem.attachment is already in binary format\n\n    binary_keys.push(key);\n\n    let linkObj = {\n        content: content,\n        shakepelink: currentItem.shakepelink,\n        name: currentItem.name,\n        imageSrc: currentItem.imageSrc,\n        enddate: formattedDate,\n        email: currentItem.email,\n        subject: currentItem.subject,\n        campaign_name: currentItem.campaign_name,\n        from: currentItem.from,\n        linkId: currentItem.linkId,\n        is_attachment_required: currentItem.is_attachment_required,\n        attachment: {\n            data: currentItem.attachment, // Use the binary data directly\n            fileName: fileName\n        },\n        binary_keys: binary_keys.slice() // Include a copy of binary_keys for each linkObj\n    };\n\n    modifiedContentArray1.push(linkObj);\n\n    // Clear binary_keys for the next iteration\n    binary_keys = [];\n}\n\nreturn [{\n    json: {\n        modifiedContentArray1: modifiedContentArray1,\n         // binary_keys: binary_keys.join(',')\n\n    },\n    binary: binaries\n}];\n*/\n\n\n\nlet dataArray = $node[\"Webhook\"].json[\"body\"];\nlet modifiedContentArray1 = [];\nlet content_array = dataArray[\"modifiedContentArray\"];\nlet content_field = dataArray[\"content_data\"];\n\n// Initialize binaries outside the loop\nlet binaries = {};\n\nfor (let i = 0; i < content_array.length; i++) {\n    let currentItem = content_array[i];\n    let formattedDate1 = currentItem.enddate;\n    let amount = parseInt(currentItem.amount);\n    const date = new Date(formattedDate1);\n    const options = { day: '2-digit', month: 'short', year: 'numeric' };\n    const formattedDate = date.toLocaleDateString('en-US', options);\n\n    let content = content_field.replace(/{link}/g, currentItem.linkId)\n        .replace(/{img}/g, currentItem.imageSrc)\n        .replace(/{shakepelink}/g, currentItem.shakepelink)\n        .replace(/{enddate}/g, formattedDate)\n        .replace(/{amount}/g, amount)\n        .replace(/{name}/g, currentItem.name);\n\n    // Build binaries for HTTP Request\n    let extension = \"pdf\";\n    let key = `data_${i}.${extension}`;\n\n    // Include the attachment directly as binary data\n    binaries[key] = currentItem.attachment; // Assuming currentItem.attachment is already in binary format\n\n\n\n    let linkObj = {\n       content: content,\n        shakepelink: currentItem.shakepelink,\n        name: currentItem.name,\n        imageSrc: currentItem.imageSrc,\n        enddate: formattedDate,\n        email: currentItem.email,\n        subject: currentItem.subject,\n        campaign_name: currentItem.campaign_name,\n        from: currentItem.from,\n        linkId: currentItem.linkId,\n        is_attachment_required: currentItem.is_attachment_required,\n        binary_keys: key\n      \n    };\n\n    modifiedContentArray1.push(linkObj);\n}\n\nreturn [{\n    json: {\n        modifiedContentArray1: modifiedContentArray1,\n        \n    },\n    binary: binaries\n}];\n"
      },
      "name": "Function4",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        140,
        860
      ]
    },
    {
      "parameters": {
        "url": "={{$node[\"HTTP Request\"].binary.data}}",
        "options": {}
      },
      "name": "HTTP Request1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        920,
        1240
      ]
    }
  ],
  "settings": {},
  "staticData": null,
  "tags": [],
  "updatedAt": "2024-01-19T13:14:03.059Z"
}